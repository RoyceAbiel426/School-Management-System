/**
 * Export Helpers for Edu-Pro
 * Provides utilities for exporting data to CSV, PDF, and Excel
 */

import { saveAs } from "file-saver";
import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import * as XLSX from "xlsx";
import { formatDate, formatDateTime } from "../dateHelpers";

/**
 * Export data to CSV format
 * @param {Array} data - Array of objects to export
 * @param {String} filename - Output filename (without extension)
 * @param {Array} columns - Array of column definitions {header: String, key: String}
 */
export const exportToCSV = (data, filename, columns) => {
  if (!data || data.length === 0) {
    console.error("No data to export");
    return;
  }

  try {
    // Create CSV header
    const headers = columns.map((col) => col.header).join(",");

    // Create CSV rows
    const rows = data.map((item) => {
      return columns
        .map((col) => {
          const value = item[col.key];

          // Handle different data types
          if (value === null || value === undefined) {
            return "";
          }

          // Escape commas and quotes in values
          const stringValue = String(value).replace(/"/g, '""');
          return stringValue.includes(",") ? `"${stringValue}"` : stringValue;
        })
        .join(",");
    });

    // Combine header and rows
    const csv = [headers, ...rows].join("\n");

    // Create blob and download
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    saveAs(blob, `${filename}_${Date.now()}.csv`);
  } catch (error) {
    console.error("Error exporting to CSV:", error);
    throw new Error("Failed to export CSV");
  }
};

/**
 * Export data to Excel format
 * @param {Array} data - Array of objects to export
 * @param {String} filename - Output filename (without extension)
 * @param {Array} columns - Array of column definitions
 * @param {String} sheetName - Name of the worksheet
 */
export const exportToExcel = (
  data,
  filename,
  columns,
  sheetName = "Sheet1"
) => {
  if (!data || data.length === 0) {
    console.error("No data to export");
    return;
  }

  try {
    // Transform data to match columns
    const worksheetData = data.map((item) => {
      const row = {};
      columns.forEach((col) => {
        row[col.header] = item[col.key];
      });
      return row;
    });

    // Create worksheet
    const worksheet = XLSX.utils.json_to_sheet(worksheetData);

    // Set column widths
    const columnWidths = columns.map((col) => ({
      wch: Math.max(col.header.length, 15),
    }));
    worksheet["!cols"] = columnWidths;

    // Create workbook
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, {
      bookType: "xlsx",
      type: "array",
    });
    const blob = new Blob([excelBuffer], {
      type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    });
    saveAs(blob, `${filename}_${Date.now()}.xlsx`);
  } catch (error) {
    console.error("Error exporting to Excel:", error);
    throw new Error("Failed to export Excel");
  }
};

/**
 * Export data to PDF format
 * @param {Array} data - Array of objects to export
 * @param {String} filename - Output filename (without extension)
 * @param {Array} columns - Array of column definitions
 * @param {Object} options - PDF options {title, orientation, pageSize}
 */
export const exportToPDF = (data, filename, columns, options = {}) => {
  if (!data || data.length === 0) {
    console.error("No data to export");
    return;
  }

  try {
    const {
      title = "Report",
      orientation = "portrait",
      pageSize = "a4",
      metadata = {},
    } = options;

    // Create PDF document
    const doc = new jsPDF({
      orientation,
      unit: "mm",
      format: pageSize,
    });

    // Add header
    doc.setFontSize(18);
    doc.text(title, 14, 20);

    // Add metadata
    if (metadata.generatedBy) {
      doc.setFontSize(10);
      doc.text(`Generated by: ${metadata.generatedBy}`, 14, 28);
    }
    if (metadata.generatedAt) {
      doc.text(`Date: ${formatDateTime(metadata.generatedAt)}`, 14, 33);
    }

    // Prepare table data
    const tableHeaders = columns.map((col) => col.header);
    const tableData = data.map((item) =>
      columns.map((col) => {
        const value = item[col.key];
        if (value === null || value === undefined) return "";

        // Format dates
        if (col.type === "date" && value) {
          return formatDate(value);
        }

        return String(value);
      })
    );

    // Add table
    autoTable(doc, {
      head: [tableHeaders],
      body: tableData,
      startY: metadata.generatedBy || metadata.generatedAt ? 38 : 25,
      theme: "grid",
      headStyles: {
        fillColor: [59, 130, 246], // Blue-500
        textColor: 255,
        fontStyle: "bold",
        halign: "left",
      },
      styles: {
        fontSize: 9,
        cellPadding: 3,
      },
      alternateRowStyles: {
        fillColor: [249, 250, 251], // Gray-50
      },
      margin: { top: 10, right: 14, bottom: 10, left: 14 },
    });

    // Add page numbers
    const pageCount = doc.internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.text(
        `Page ${i} of ${pageCount}`,
        doc.internal.pageSize.width / 2,
        doc.internal.pageSize.height - 10,
        { align: "center" }
      );
    }

    // Save PDF
    doc.save(`${filename}_${Date.now()}.pdf`);
  } catch (error) {
    console.error("Error exporting to PDF:", error);
    throw new Error("Failed to export PDF");
  }
};

/**
 * Generate print-friendly view
 * @param {String} elementId - ID of element to print
 */
export const printElement = (elementId) => {
  const element = document.getElementById(elementId);
  if (!element) {
    console.error(`Element with ID "${elementId}" not found`);
    return;
  }

  const printWindow = window.open("", "_blank");
  printWindow.document.write(`
    <!DOCTYPE html>
    <html>
      <head>
        <title>Print</title>
        <link rel="stylesheet" href="/print.css">
        <style>
          @media print {
            @page { margin: 1cm; }
            body { margin: 0; padding: 20px; }
          }
        </style>
      </head>
      <body>
        ${element.innerHTML}
      </body>
    </html>
  `);
  printWindow.document.close();
  printWindow.focus();
  setTimeout(() => {
    printWindow.print();
    printWindow.close();
  }, 250);
};

/**
 * Export multiple sheets to Excel
 * @param {Array} sheets - Array of {data, columns, sheetName}
 * @param {String} filename - Output filename
 */
export const exportMultipleSheetsToExcel = (sheets, filename) => {
  if (!sheets || sheets.length === 0) {
    console.error("No sheets to export");
    return;
  }

  try {
    const workbook = XLSX.utils.book_new();

    sheets.forEach(({ data, columns, sheetName }) => {
      // Transform data
      const worksheetData = data.map((item) => {
        const row = {};
        columns.forEach((col) => {
          row[col.header] = item[col.key];
        });
        return row;
      });

      // Create worksheet
      const worksheet = XLSX.utils.json_to_sheet(worksheetData);

      // Set column widths
      const columnWidths = columns.map((col) => ({
        wch: Math.max(col.header.length, 15),
      }));
      worksheet["!cols"] = columnWidths;

      // Add to workbook
      XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
    });

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, {
      bookType: "xlsx",
      type: "array",
    });
    const blob = new Blob([excelBuffer], {
      type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    });
    saveAs(blob, `${filename}_${Date.now()}.xlsx`);
  } catch (error) {
    console.error("Error exporting multiple sheets:", error);
    throw new Error("Failed to export Excel");
  }
};

/**
 * Export formatted report with custom styling
 * @param {Object} config - Report configuration
 */
export const exportCustomReport = (config) => {
  const {
    title,
    subtitle,
    data,
    columns,
    filename,
    format = "pdf",
    summary = {},
    footer = "",
  } = config;

  if (format === "pdf") {
    const doc = new jsPDF("portrait", "mm", "a4");

    // Header
    doc.setFontSize(20);
    doc.setTextColor(31, 41, 55); // Gray-800
    doc.text(title, 14, 20);

    if (subtitle) {
      doc.setFontSize(12);
      doc.setTextColor(107, 114, 128); // Gray-500
      doc.text(subtitle, 14, 28);
    }

    let yPosition = subtitle ? 35 : 28;

    // Summary section
    if (Object.keys(summary).length > 0) {
      doc.setFontSize(10);
      doc.setTextColor(0, 0, 0);
      Object.entries(summary).forEach(([key, value]) => {
        doc.text(`${key}: ${value}`, 14, yPosition);
        yPosition += 5;
      });
      yPosition += 5;
    }

    // Table
    const tableHeaders = columns.map((col) => col.header);
    const tableData = data.map((item) =>
      columns.map((col) => String(item[col.key] || ""))
    );

    autoTable(doc, {
      head: [tableHeaders],
      body: tableData,
      startY: yPosition,
      theme: "striped",
      headStyles: {
        fillColor: [59, 130, 246],
        textColor: 255,
        fontStyle: "bold",
      },
    });

    // Footer
    if (footer) {
      const finalY = doc.lastAutoTable.finalY || yPosition;
      doc.setFontSize(8);
      doc.setTextColor(107, 114, 128);
      doc.text(footer, 14, finalY + 10);
    }

    doc.save(`${filename}_${Date.now()}.pdf`);
  } else if (format === "excel") {
    exportToExcel(data, filename, columns);
  } else if (format === "csv") {
    exportToCSV(data, filename, columns);
  }
};
